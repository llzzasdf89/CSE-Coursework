                                                CSE112 Week 7 笔记
Knowledge Representation （知识呈现）指的是能够以一种合适的计算机语言表达真实世界的知识的方式
在人工智能领域中我们常常使用推断引擎已经知识库去推测一些未知的知识。其执行过程为：
在推断引擎中加入一些与定义域无关的算法，这些算法在这可以理解为一些条件或者问题。推断引擎会向知识库（knowledge base)发出询问、知识的请求。在获取了这些知识后结合其算法推断出新结论、知识
知识库：知识库是由一系列已知的知识组成的类似于数据库的仓库
推断引擎是由算法和推断和推断规则组成的，推断规则是一系列规则，这些规则是建立在已有知识上的。正是由于推断规则的存在，所以推断引擎推测出的结果一定是建立在已有知识上推测出的结果。

知识呈现可以以逻辑命题的方式呈现
使用命题逻辑表现知识呈现的步骤:
1.以命题逻辑的方式描述在特定领域中实际存在于知识库的知识，这里特定领域可以被理解为解题时候的问题涉及领域。
2.生成一个推断a 
3.尝试着证明 已知知识（KB）=>a 是正确的

蕴涵：蕴涵可以理解为包含.其含义为一件事由另一件事衍生而来。 其符号以KB |= a 表示。
KB 蕴涵语句a 当且仅当a 在KB任何情况下都为真的时候成立。 蕴涵还有另外一种说法：a 是 KB 的逻辑结果
推断：推断可以由符号KB ⊢i a 表示，其中i是算法（理解为规则或者条件都可以）。 其寓意是 KB(已知知识) 在规则i下可以推断出命题 a 的成立 .
算法 i 有两种性质：
1.稳健性(soundness): 一个算法只能(关键词)推断出被蕴涵的句子，那么就称这个算法为健壮性的， 用符号表示为i 是稳健的如果无论何时 KB ⊢i a (KB推断出a), 那么就可以说KB蕴涵a 
2.完整性(completeness): 一个算法可以推断出任何被蕴涵的句子，用符号表示为 i 是完整的 如果无论何时KB |= a , KB ⊢i a 也是成立的
两种性质可以理解为相反关系，稳健性是由推断关系推出蕴涵关系，而完整性是由蕴涵关系推断出推断关系

推断常用规则：
在推断规则中存在着一些常用规则，这些规则都是经过证明的并且可以直接参与逻辑命题真值计算中使用的，有了这些规则以后可以减少真值表的使用从而快速找到答案
规则1 : 命题演算分离规则（英文名：modus ponens）
其规则描述如下： 给定前提a, a=>b为真，那么b也必为真。
可以这么理解，a=>b为真，说明b只有可能为真，但是只有这个前提不够，因为a为假b为真时，a=>b仍然为真。所以若加入前提a为真，那么一定可以说明b为真才能使得a=>b成立。
规则2：消除(英文名:Elimination) : 其描述为我们可以从连接当中推断出参与连接的连接项的真值。 例如a^b为真，那么一定可以推断出a或b为真
规则3：连接引进（∧introduction): 其描述为如果a为真并且b为真，那么a连接b一定为真
规则4：析取引进（∨introduction）:其描述为如果A为真，那么A∨B一定为真
规则5：双重否定消除:其描述为一个命题若取反两次，则其真值和原命题相同。 即┐┐A 等价于 A 
规则6：决议: 其描述为如果我们知道“A或B”为真且我们知道“非B或C”为真，那么我们就可以得出“A或C”为真的结论。

逻辑命题的证明：不考虑解释的逻辑命题推理被称为逻辑命题的证明。
其证明方法如下：在给定了已知条件的时候，根据已知条件产生正确结论或命题
证明健壮性和完整性。证明健壮性和完整性其实方法就是从定义出发，一般情况下是给定规则Ai（i是不定的，可能有很多个），这些Ai都能推出命题 B。 尝试着证明A1 ∧A2 ∧ A3...∧Ai |= B
完整性：完整性的证明和健壮性相反 一般给定条件是A1 ∧A2 ∧ A3...∧An |= B, 尝试着证明An都能推出命题 B


                                        Week8&9 笔记
有效性(validity)：如果在任何情况下（关键词）一个句子的真值为真，那么我们称这个句子是有效的（valid)或称之为同义反复的(tautology)。
有效性是和推断定理相联系的：1.KB 蕴涵 a 当且仅当 KB=> a 为有效的时候成立。
                       2.或者我们可以说KB蕴涵a 当且仅当(KB ^ ┐a)为不可满足的时候成立，两种说法都是一样的。
此时需要引进剩下两个概念：
1.不可满足的(unsatisfiable):对于任何一个命题逻辑句子，在任何情况下（关键词）真值恒为假，我们则称这种句子为不可满足的句子
2.可满足的(satisfiable): 对于任何一个命题逻辑句子，存在至少一种情况（关键字）能够使得该句子真值为真，则这种句子我们称之为可满足的句子
        另外存在反向证明定理: 如果一个命题逻辑句子 a 是有效的，那么它的否命题┐a一定是不可满足的
验证句子可满足性的方法：
1.列举真值表，将该句子在所有解释下（情况）下的真值列举出来，从而判断该句子的真值情况如何。
但是列举真值表的方法在某些情况下效率会特别低，根据一个句子的命题变元的多少，一个真值表可以包含2的n次方行以及2的n次方步骤。 因此这个方法不推崇
真值表方法适合使用在变元数较少的情况下
2.反向思考法： 有些命题逻辑的句子并不是特别好判断真值，我们可以将它反向更改格式后进行判断。例如KB 蕴含 a 我们完全可以将其改变成KB∧┐a的形式来进行判断
推理过程： KB蕴涵a 可以被改写为 ┐KB∨a （蕴涵可以理解为 kb => a, 而根据kb => a 即蕴含的定义， 蕴含的式子和析取的式子等价，所以 kb => a 可以被改写为 ┐KB v a )
而根据之前的反向证明定理 一个命题逻辑句子a是有效的，那么它的否命题一定是不可满足的。 而 ┐KB v a的否命题为 ┐( ┐KB v a) ， 即 KB ∧ ┐a )
所以说证明KB 蕴涵 a 的反向证明方法即为证明 KB ∧ ┐a 命题逻辑句子为不可满足的。
而KB一般是由知识库给出的，所以给出来的KB问题真值一般都是为true的。 所以反向思考问题在这个程度上被转换成了
确认命题 a 的真值，这样效率比起真值表高出了一大截
3. 等价式转换法：
等价式子： 等价式子指的是对于两个命题逻辑句子 A 和 B ， 若这两个句子在任何解释下他们的真值都 相同（关键词）， 那么这两个句子被称为等价式句子
等价式句子被写作 A ≡ B。 
因为等价式子的存在，其允许我们将复杂的命题逻辑句子可以转换为更简单的句子从而列举真值表解决问题。 
对于等价式子的转换， 常用下述几种转换定律：
幂等律： A ∧ A ≡ A , A v A ≡ A
结合律： (A ∧ B) ∧ C ≡ A ∧ (B ∧ C), (A v B) v C ≡ A v (B v C)
交换律: A ∧ B ≡ B ∧ A ， A v B ≡ B v A
分配律: A ∧ (B v C) ≡ (A ∧ B) v (A ∧ C), A v (B ∧ C) ≡ (A v B) ∧ (A v C)
同一律: A ∧ T ≡ A, A v F ≡ A, A ∧ F ≡ F, A v T ≡ T
补充律: A ∧  ┐A ≡ F, A v ┐A ≡ T, ┐(┐ A) ≡ A,  ┐T ≡ F, ┐F ≡ T
得摩根定律：┐(A ∧ B) ≡ ┐ A v ┐B, ┐(A v B) ≡ ┐A ∧ ┐B
A=>B ≡ ┐A v B
A<=>B ≡ (A => B) ∧ (B => A)

根据这些定律，一些经典常用的格式被总结了出来，并且可以简化运算
格式1. 否定格式
A<=>B 化为 (A=>B) ∧ (B=>A)
A=>B 化为 ┐A v B
┐(A ∧ B) 化为 ┐A v ┐B
┐(A v B) 化为  ┐A ∧ ┐B
┐┐A 化为 A
┐(A=>B) 化为 A ∧ ┐B
格式2.连接式
连接式是以A1 ∧ A2 ∧ A3 ∧.....Ak
根据等价式定律再结合常用格式的运算， 我们可以很大程度上减少真值计算的量

                                Week10 笔记
在命题逻辑中，一个字母代表一个原子命题或者是一个原子命题的否定，如p和┐p.
子句：子句是一系列字母的集合。 而一个包含了唯一一个字母的子句称之为单位子句.
子句语句：子句语句指的是一个单独的一个字母亦或者是一系列字母通过析取连接的字母
从上述三个例子中可以推出下面一个常用形式：
子句形式： 存在一系列w1,w2,w3,w4,...wn，这些wi组成了一个集合。并且该集合中每一个wi都是子句的话，那么我们便称这种形式为子句形式
子句形式是仅包含通用量化变量的文字的分离
空集：对于子句形式，不可能存在空集， 这是因为该问题等价于找一个空的析取命题。 这个问题也可以理解为，不可能存在没有字母的原子命题，因为一个字母也是子句
转换成子句形式的步骤：
1.对于蕴含形式，就是将蕴含形式通过等价式转换为析取形式，该析取形式就是一个子句形式
2.否定形式：对于否定形式，将其使用得摩根定律拆分以后便可实现
3.对于分布式，将分布式括号拆开以后实现
注意：最后形式为析取式，即a1 v a2 v a3 v .....an的时候，转换成子句形式为一个集合{a1,a2,a3....an}
但如果最后形式为合取式，即a1 ∧ a2 ∧ a3 ∧ ....an的时候，转换成子句形式为多个集合{a1},{a2},{a3},...{an}
这是和定义不矛盾的，因为合取式的基本单位为字母，而字母也是子句形式的一种。
溶解法则：
溶解法则包括：1.将所有命题转换为一般形式CNF
            2.在每一步，一个新的子句都会被用来和已有的两个子句之间做推断
            3.证明步骤永远都是使用这个方法：溶解法则
            4.溶解步骤在整个步骤结果返回false的时候或者没有新的子句可以用来推断时停止
溶解法则过程：
以A1,A2..Ai举例， 每一个Ai都已经是子句了。 我们将其子句形式化，即放在一个集合里{A1,A2,A3....Ai}，这个集合称作A
溶解法则要做的事情如下，将新的子句命名为p，尝试判断 A v p的真值，B v ┐p的真值，从而推断A v B的真值，其中B是另一个子句形式
在这个过程中 A v B就叫做溶剂， A v p 和 B v ┐p 叫做溶解物的父母
p 和  ┐p 叫做补充字母
注意在上述步骤里面 A 或 B 可能是空集
溶解法则在知识呈现中的应用:
溶解法则和知识呈现是通过蕴涵的定义连接起来的
在蕴涵中有定理 KB 蕴涵 a 当且仅当 KB=> a 是有效的，或者说KB蕴涵 a 当且仅当KB ∧ ┐a是不可满足的时候该蕴涵才成立
假设知识库给定的知识为 P v Q, P => R , Q => R, 要求证明 R
首先根据等价式， P => R ≡ ┐P v R, Q => R ≡ ┐Q v R ,将这些式子化成一般式
其次对于这些一般式， 使用溶解定律。 因为P v Q 为真， ┐P v R也为真，那么Q v R 为真
其次┐Q v R为真，Q v R也为真，从而能推断出 R一定为真。
从而，根据之前的蕴涵定理，KB(在这里为P v Q,P => R,Q => R) ∧ ┐R一定为不可满足的。从而推断出KB 蕴涵 R
对于溶解法则的推广
溶解法则是从命题演算分离定理演化而来的，在命题演算分离定理中我们知道当一个蕴含式的前提为真时，结果一定为真
那么假设给定前提为 P，以及蕴涵式 P => B，根据命题演算分离定理则一定有 B为真.因为在知识呈现中给定的前提其真值一定是为真的
那么再推广一下就有给定前提 A => P , P => B, 则一定存在A => B 为真的情况, 这里的格式就和溶解定律一样了
对于这个推广式可以这样理解，给定的前提 A => P 以及 P => B,那么说明P和B一定为真，但是A的真假并不知道。但是由于B为真，A => B 是一定为真的。

自动推理：溶解法则已经被广泛运用于人工智能领域，并且可以由计算机程序执行， 关于这方面的理论早已被很多科学家提出，例如Otter,Spass
在应用方面，搜索问题作为一个可满足性问题就完全可以使用溶解定律解决
例如，将KB ∧ ┐a 化成一般形式, 这种问题就属于可满足性问题

另外，状态的赋值也是一种搜索问题。状态在搜索问题中也被称作部分任务。有些命题有真值，但是有一部分就没有。这个时候需要做的就是对当前命题做判断并赋予一个适当的真值
初始状态：空的任务
目标状态：一种能使得任务真值为true的不同命题的安排方式
在这里有几种算法解决这个问题，如DP算法，DLL/DPLL算法，Stalmarcks算法，Stochastic搜索算法
DPLL算法：一种完善的向后追溯的算法，其思路为每一个命题在任何解释下只有真或假两种可能。 其运用了一个深度搜索的方式，尝试为每个命题进行赋值。
该算法通过选择一个字母，为其分配一个真值，对公式进行简化，然后递归地检查简化后的公式是否可以满足
如果可以，原来的公式是可以满足的 否则，假设相反的真值，则执行相同的递归检查。
这就是所谓的分割规则，因为它将问题分割成两个更简单的子问题。
简化版本的步骤基本上就是从公式中删除赋值项下为true的所有子句，并从其余子句中删除所有为false的字母。


                        Week11 笔记
命题逻辑的优缺点：语法片段与事实相对应， 允许部分/分离/否定信息（与大多数数据结构和数据库不同）
组成的：如B1 ∧ B2 的意思是从B1和 B2的意思推断出来的，即复合句的意思是可以由单个命题推断出来的
另外，命题的意思是与上下文无关的，不像自然语言中一句话的意思是要根据上下文综合考虑的。 但是命题逻辑缺点也很明显，那就是它所能表达的意思特别有限，不像自然语言那么丰富
为了填补这个空缺，一阶逻辑的概念被首次提出并沿用至今
一阶逻辑：在命题逻辑中，整个世界是由事实组成的。但是在一阶逻辑中，整个世界包含三样东西：物体，关系，函数
举例来说
course_lecturer(Feng,CSE112)
male(Feng)
< (3, 4)
< (4, plustwo(1))
mammal(Katy) 
上述例子皆为谓词逻辑的语句，其中Feng, Katy, CSE112, 3, 4 and 1 都是常量 (物体).
course_lecturer, male, < and mammal都是谓词（关系）
plustwo 是一个函数 (函数用来指向其他物体，在这里plustwo(1)即为1+2指向物体3)
需要注意 ： 数学关系<,>,≤,≥,=, != 同样是谓词，可以标示出两个物体之间的关系。 函数实质上是一种特殊的关系（谓词），如果不需要严谨区分的话，两者完全可以替换使用。但是在某种场合下，利用谓词字母表达函数的性质所得到的公式可读性并非很好。正因为如此，那些作为函数符号的字符通常是谓词逻辑的一部分。
除此之外，对于一阶逻辑的解释，我们称之为定义域
和命题逻辑的解释相同，定义域的作用是划定物体、关系、功能的取值范围的
论域：论域指的是在谓词逻辑中该话题所感兴趣的物体，也可以说论域就是谓词逻辑中每个变量的取值范围。
术语(Terms): 术语是对于物体的解释，常量，变量，函数都是术语。术语是上述对象的语法对应物。常量表示域的元素，函数符号表示引用这些对象的方法。
原子语句：原子语句类似于命题逻辑中的命题
原子语句是应用于术语列表的谓词，并且用小括号包裹，例如：
cat(Katy), male(father_of(feng)), shares_office(Paul,Tim)
复杂句：和命题逻辑一样，我们可以将原子语句用一些命题逻辑中的符号将其连接起来(∧, ∨, ⇒, ┐, <=> ).
例如male(Trump)=>┐female(Trump)
一阶逻辑中（又称谓词逻辑）需要注意的几点：
1.带有变量的谓词不是命题，例如x>1 变量是x谓词是>,这种语句不能构成谓词逻辑，因为在论域中，x取的数不定，无法判断这个值的真假。若想让其成为谓词逻辑，我们需要加入额外的定义域（该点提醒我们在构建谓词逻辑时候需要加入定义域）
2.简单的说，若想构建一个谓词逻辑，那么需要做到：给变量赋值，使用量词量化变量

对于量化来说，一阶逻辑里也有专门的两个量化符号∀表示所有，∃表示存在。就以上述 x>1的例子来说，在我们量化以后可以表达为 ∀x, x>1，该句的含义便成为了对于所有x，x>1。 
加入了量化符号以后，该命题便可以判断其真值如何，因此它也成为了一个命题。所有符号也被称作为论域符号，意思为可以取整个论域中的值，它有点类似于命题逻辑中的合取符号
例如：假设论域为{2,4,6}那么，谓词命题∀x Even(x)，即对于x来说， 论域中的所有x可能的偶数值。这就和Even(2)∧ Even(4)∧ Even(6)相同
另外通常,与⇒是∀主要的连接。例如:∀x, female(x) ⇒ ┐male(x)，这句话的含义为我们知道了x代表女人，那么我们一定可以推断出x不是男人
注意在使用命题逻辑符号的时候一定要慎重考虑，因为稍不注意整个谓词逻辑所表达的含义就是错误的。如∀x · At(x,Berkeley) ∧ Smart(x)。它的意义被翻译成了为
每个人都在伯克利，并且每个人都很聪明。 而我们一般想表达的意思为每个在伯克利的人他们都很聪明，所以此时不能使用合取而应该用蕴含符号∀x · At(x,Berkeley) => Smart(x)才正确

存在量词：存在量词在命题逻辑中和析取符号类似
例如上述的例子{2,4,6}中，我们将谓词更换为∃n · Even(n)，那么该含义为存在一个n它是偶数。
这个含义在命题逻辑中就和Even(2) v Even(4) v Even(6)是等价的.在{2,4,6}中存在n它是偶数，那么这个n按道理来说就是2或者4或者6。 正是因为如此我们才说存在量词某种程度上等价于析取符号
与全部量词相反，存在量词一般常用的连接符号为合取∧而非蕴含=>。
例如我们给定定义域{Sam,Jim, Suzy} 并且在此中Sam和Jim都是男人，Sam是父亲但Jim不是，并且Suzy既不是男人也不是父亲
那么∃x · man(x) ∧ father(x) 实际含义为：(man(Sam) ∧ father(Sam))∨ (man(Jim) ∧ father(Jim))∨ (man(Suzy) ∧ father(Suzy))。在这个命题中只有man(Sam) ∧ father(Sam)能使得该命题成立。

分析：之所以量词不同与之搭配的常用命题连接符号不同，是因为参与谓词运算的范围大小不同造成的。
对于全部量词，以∀x · At(x,Berkeley) => Smart(x)为例。x在参与谓词运算的时候，其本身范围就代表了所有人，所以使用合取符号会造成逻辑错误。
对于全称量词中，x所代表的范围仅仅为一个人，并且是指定的论域中的某个人，所以我们在对这个人进行运算的时候使用合取符号并不会造成逻辑错误。
以同一个例子作为举例，若将其换为∃x · At(x,Berkeley) ∧ Smart(x)，那么其含义为指定了在论域中的某个人，这个人既在伯克利并且又聪明，这在语义上和逻辑上是完全说得通的。
但若将其换为∃x · At(x,Berkeley) => Smart(x)，那么该含义便成为了，假如它是指定的某个人，那么它很聪明。这样就和存在量词的使用相互冲突了，因为在使用存在量词的时候就已经假定了它是这个人，而若对其再假设一遍，会造成逻辑上和语义上的冲突

量词嵌套：两个量词会形成嵌套，如果一个量词在另一个量词的范围内
例如
∀x ∃y (x + y = 0)
这就是一个很典型的嵌套例子。
我们可以将x+y=0看成一个谓词称之为P(x,y)，再加上其前面的量词∃y构成了第二个谓词Q(∃y P(x,y))(Q(x))
那么这个题目便成为了，∀x Q(x)，其含义为对于所有x来说满足Q(x), 其中Q(x)为存在一个y能使得P(x,y)成立。P(x,y)是x+y=0
那么简单的说就是对于所有x，存在一个y能使得x+y=0
这样便形成了三层嵌套
将谓词逻辑翻译成自然语言的步骤：嵌套的语义为从左到右，从外层到内层逐层翻译
将自然语言翻译成谓词逻辑的步骤：首先尝试翻译成对于所有。。或者存在某个。。x,y能够使得某种关系成立的句子(这种格式称之为逻辑格式），拆分成这种格式后，尝试着分析其内外层关系。一般内外层关系是从左到右依次递进的。紧接着再尝试使用量词符号及谓词符号将其翻译为谓词逻辑
对于嵌套这一块，更多的是需要练习翻译的能力。只要能够将题目成功翻译出来，那么构建谓词逻辑的时候自然不会存在问题。
嵌套量词的顺序：
对于嵌套量词的顺序来说，只有一个原则：在没有其他量词的语句中，可以在不更改量词的含义的情况下更改嵌套的通用量词的顺序。
换句话说就是如果该命题逻辑中所需要的量词为同一种的话，那么顺序可以任意变更。


